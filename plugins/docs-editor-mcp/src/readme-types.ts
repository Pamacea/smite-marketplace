/**
 * Core types for README Updater Tool
 * Following SMITE engineering rules: Zod validation, Result types, immutable structures
 */

import { z } from 'zod';

/**
 * Result type for error handling (pattern matching style)
 */
export type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

/**
 * Dependency information from package.json
 */
export interface DependencyInfo {
  name: string;
  version: string;
  type: 'dependency' | 'devDependency';
}

/**
 * Dependency change detection result
 */
export interface DependencyChange {
  added: DependencyInfo[];
  updated: DependencyInfo[];
  removed: DependencyInfo[];
  unchanged: DependencyInfo[];
}

/**
 * Project structure node (file or directory)
 */
export interface StructureNode {
  path: string;
  name: string;
  type: 'file' | 'directory';
  children?: StructureNode[];
  depth: number;
}

/**
 * Project structure change
 */
export interface StructureChange {
  type: 'added' | 'removed' | 'modified';
  path: string;
  itemType: 'file' | 'directory';
}

/**
 * README section information
 */
export interface ReadmeSection {
  name: string;
  level: number; // Heading level (1-6)
  lineStart: number;
  lineEnd: number;
  content: string;
  isProtected: boolean; // Has SMITE:MANUAL marker
  isAutoGenerated: boolean; // Has SMITE:AUTO marker
}

/**
 * Section update content
 */
export interface SectionUpdate {
  sectionName: string;
  oldContent: string;
  newContent: string;
  lineStart: number;
  lineEnd: number;
}

/**
 * Project analysis result
 */
export interface ProjectAnalysis {
  dependencies: DependencyChange;
  structure: StructureChange[];
  framework: string | null;
  readmePath: string;
  sections: Map<string, ReadmeSection>;
}

/**
 * Zod schemas for validation (parse, don't validate!)
 */

/**
 * Input schema for update_readme_architecture tool
 */
export const UpdateReadmeInputSchema = z.object({
  projectPath: z.string().min(1, 'Project path is required'),
  readmePath: z.string().default('README.md'),
  sectionsToUpdate: z.array(z.enum(['installation', 'architecture', 'structure', 'all'])).default(['all']),
  generateDiff: z.boolean().default(true),
  preserveMarkers: z.boolean().default(true),
});

export type UpdateReadmeInput = z.infer<typeof UpdateReadmeInputSchema>;

/**
 * Output schema for update_readme_architecture tool
 */
export const UpdateReadmeOutputSchema = z.object({
  success: z.boolean(),
  sectionsUpdated: z.array(z.string()),
  dependenciesAdded: z.number(),
  dependenciesUpdated: z.number(),
  dependenciesRemoved: z.number(),
  modulesAdded: z.number(),
  modulesRemoved: z.number(),
  diff: z.string().optional(),
  readmePath: z.string(),
  warnings: z.array(z.string()).optional(),
});

export type UpdateReadmeOutput = z.infer<typeof UpdateReadmeOutputSchema>;

/**
 * Framework detection patterns
 */
export const FRAMEWORK_PATTERNS = {
  nextjs: ['next.config.', 'pages/', 'app/'],
  express: ['express', 'routes/', 'server.ts'],
  fastapi: ['fastapi', 'main.py', 'routers.py'],
  nestjs: ['@nestjs/', 'main.ts', '.module.ts'],
  react: ['react', 'src/App.', 'src/components/'],
  vue: ['vue', 'src/App.vue'],
  angular: ['@angular/', 'angular.json'],
} as const;

export type Framework = keyof typeof FRAMEWORK_PATTERNS;

/**
 * Manual edit markers (preserve these sections)
 */
export const MANUAL_MARKER_START = '<!-- SMITE:MANUAL:START -->';
export const MANUAL_MARKER_END = '<!-- SMITE:MANUAL:END -->';

/**
 * Auto-generated content markers (can be overwritten)
 */
export const AUTO_MARKER = '<!-- SMITE:AUTO -->';

/**
 * Section mapping (common README section names)
 */
export const SECTION_ALIASES: Record<string, string[]> = {
  installation: ['installation', 'install', 'setup', 'getting started', 'quickstart'],
  architecture: ['architecture', 'design', 'system design', 'technical overview'],
  structure: ['project structure', 'structure', 'directory structure', 'folder structure', 'file organization'],
  usage: ['usage', 'how to use', 'using', 'examples'],
  contributing: ['contributing', 'contribution', 'contribute'],
  license: ['license', 'licence'],
};

/**
 * Helper function to normalize section names
 */
export function normalizeSectionName(name: string): string | null {
  const lowerName = name.toLowerCase().trim();

  for (const [canonical, aliases] of Object.entries(SECTION_ALIASES)) {
    if (aliases.some(alias => lowerName.includes(alias))) {
      return canonical;
    }
  }

  return null;
}

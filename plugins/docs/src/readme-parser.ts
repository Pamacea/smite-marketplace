/**
 * README Parser - Parse and analyze README.md structure
 * Uses unified/remark for markdown parsing (verified with official docs)
 * Source: https://github.com/remarkjs/remark/blob/main/packages/remark-parse/readme.md
 * Following SMITE engineering rules: Pure functions, immutable data, Result types
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkStringify from 'remark-stringify';
import type { Root } from 'mdast';
import {
  ReadmeSection,
  Result,
  normalizeSectionName,
  MANUAL_MARKER_START,
  MANUAL_MARKER_END,
  AUTO_MARKER,
} from './readme-types.js';

/**
 * Load README.md content
 */
export async function loadReadme(readmePath: string): Promise<Result<string>> {
  try {
    const content = await fs.readFile(readmePath, 'utf-8');
    return { success: true, data: content };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error(String(error)),
    };
  }
}

/**
 * Parse README markdown into AST and extract sections
 */
export async function parseReadmeSections(
  readmePath: string
): Promise<Result<Map<string, ReadmeSection>>> {
  // Load content
  const loadResult = await loadReadme(readmePath);
  if (!loadResult.success) {
    return { success: false, error: loadResult.error };
  }

  const content = loadResult.data;
  const lines = content.split('\n');

  try {
    // Parse markdown using unified/remark
    // According to remark-parse docs: https://github.com/remarkjs/remark/blob/main/packages/remark-parse/readme.md
    const processor = unified().use(remarkParse);
    const ast = processor.parse(content) as Root;

    const sections = new Map<string, ReadmeSection>();
    let currentSection: ReadmeSection | null = null;
    let sectionContent: string[] = [];
    let inProtectedRegion = false;

    // Iterate through lines to build sections
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Check for manual edit markers
      if (line.includes(MANUAL_MARKER_START)) {
        inProtectedRegion = true;
        if (currentSection) {
          currentSection.isProtected = true;
        }
        continue;
      }

      if (line.includes(MANUAL_MARKER_END)) {
        inProtectedRegion = false;
        continue;
      }

      // Check for auto-generated marker
      if (line.includes(AUTO_MARKER)) {
        if (currentSection) {
          currentSection.isAutoGenerated = true;
        }
        continue;
      }

      // Detect heading (Markdown headings start with #)
      const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);

      if (headingMatch) {
        // Save previous section
        if (currentSection) {
          currentSection.content = sectionContent.join('\n');
          currentSection.lineEnd = i - 1;
          sections.set(currentSection.name, currentSection);
        }

        // Start new section
        const level = headingMatch[1].length;
        const rawName = headingMatch[2].trim();
        const normalizedName = normalizeSectionName(rawName) || rawName;

        currentSection = {
          name: normalizedName,
          level,
          lineStart: i,
          lineEnd: i,
          content: '',
          isProtected: inProtectedRegion,
          isAutoGenerated: false,
        };
        sectionContent = [line];
      } else if (currentSection) {
        sectionContent.push(line);
      }
    }

    // Save last section
    if (currentSection) {
      currentSection.content = sectionContent.join('\n');
      currentSection.lineEnd = lines.length - 1;
      sections.set(currentSection.name, currentSection);
    }

    return { success: true, data: sections };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error(String(error)),
    };
  }
}

/**
 * Extract specific section content by name
 */
export function extractSection(
  sections: Map<string, ReadmeSection>,
  sectionName: string
): ReadmeSection | null {
  // Try exact match
  if (sections.has(sectionName)) {
    return sections.get(sectionName)!;
  }

  // Try aliases
  const normalized = normalizeSectionName(sectionName);
  if (normalized && sections.has(normalized)) {
    return sections.get(normalized)!;
  }

  return null;
}

/**
 * Check if a section exists in the README
 */
export function hasSection(
  sections: Map<string, ReadmeSection>,
  sectionName: string
): boolean {
  return extractSection(sections, sectionName) !== null;
}

/**
 * Get all protected section names
 */
export function getProtectedSections(sections: Map<string, ReadmeSection>): string[] {
  return Array.from(sections.values())
    .filter(s => s.isProtected)
    .map(s => s.name);
}

/**
 * Get all auto-generated section names
 */
export function getAutoGeneratedSections(sections: Map<string, ReadmeSection>): string[] {
  return Array.from(sections.values())
    .filter(s => s.isAutoGenerated)
    .map(s => s.name);
}

/**
 * Merge new content with existing section while preserving manual edits
 */
export function mergeSectionContent(
  existingSection: ReadmeSection,
  newContent: string,
  preserveManual: boolean = true
): string {
  if (!preserveManual || !existingSection.isProtected) {
    // Auto-generated section, can overwrite
    return newContent;
  }

  // Protected section - preserve manual edits
  // Extract content between manual markers if they exist
  const lines = existingSection.content.split('\n');
  const startIdx = lines.findIndex(l => l.includes(MANUAL_MARKER_START));
  const endIdx = lines.findIndex(l => l.includes(MANUAL_MARKER_END));

  if (startIdx >= 0 && endIdx >= 0) {
    // Preserve manual content
    const manualContent = lines.slice(startIdx + 1, endIdx).join('\n');
    // Insert manual content into new content
    const newLines = newContent.split('\n');
    newLines.splice(startIdx + 1, 0, manualContent);
    return newLines.join('\n');
  }

  return newContent;
}

/**
 * Generate markdown diff (unified format)
 */
export function generateMarkdownDiff(
  oldContent: string,
  newContent: string
): string {
  // Simple line-by-line diff
  const oldLines = oldContent.split('\n');
  const newLines = newContent.split('\n');

  let diff = '';
  let oldIdx = 0;
  let newIdx = 0;

  while (oldIdx < oldLines.length || newIdx < newLines.length) {
    const oldLine = oldLines[oldIdx];
    const newLine = newLines[newIdx];

    if (oldLine === newLine) {
      diff += ` ${oldLine}\n`;
      oldIdx++;
      newIdx++;
    } else if (oldLine && (!newLine || oldIdx < oldLines.length)) {
      diff += `-${oldLine}\n`;
      oldIdx++;
    } else if (newLine && (!oldLine || newIdx < newLines.length)) {
      diff += `+${newLine}\n`;
      newIdx++;
    }
  }

  return diff;
}
